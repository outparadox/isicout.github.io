---
title: NDK in Android
date: 2017-05-02 16:36:41
tags: [NDK, JNI, Android]
thumbnail: https://www.pinterest.com/pin/419890365235460556/
---

Android NDK  简单来说就是可以让你的应用使用natice-code语言, （比如C ,C++)的工具集

一：what is the ndk 

 Ndk 是允许你在你的工程中可以使用native-code (比如C or c++)的工具, 你可以利用ndk来构建你的natice-app
 正如我们知道的那样, Java 是构建android app 的默认语言, 然而, java 代码很容易被反编译, 但是这对C++ code 来说这并不简单, 并且c++ 代码更加高效

<!-- more -->

二：why is ndk

C++ 代码反编译困难 

对于计算复杂量大的代码, C or C++ code can increase the performance of your app

三：buliding native app

如果你使用android studio 开发, 你需要下载安装ndk包, More info: [NDK](https://developer.android.com/ndk/downloads/index.html?hl=zh-cn)

1, 首先在代码中声明要在C++ code中要实现的native方法

``` java
/**
 * auth:huanjulu
 */
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        ((TextView) findViewById(R.id.text)).setText(nativeMethod());
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
    /**
     * native code
     *
     * @return
     */
    public native String nativeMethod();

}


```

2, 对包含`native` 关键字方法的类, 生成`.h` 头文件

进入到本地Java文件夹下 ,在Terminal input the follow commond

``` java
 javah -d ../jni jniproject.ndkproject.MainActivity
```

first , `jniproject.ndkproject` is your package name  and `MainActivity` is the class name that contains native code

and after that , you can see the `.h` file of  `MainActivity` class , it looks like :

![Qualified types](http://opd7g7we7.bkt.clouddn.com/WX20170503-174729.png)

and we can looks what contents it contains

``` bash

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class jniproject_ndkproject_MainActivity */

#ifndef _Included_jniproject_ndkproject_MainActivity
#define _Included_jniproject_ndkproject_MainActivity
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     jniproject_ndkproject_MainActivity
 * Method:    nativeMethod
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_jniproject_ndkproject_MainActivity_nativeMethod
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

```

3, `android.mk``application.mk` file

在你的jni directory, 新建`android.mk`, 

``` bash

LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE := hellojni
LOCAL_SRC_FILES := hellojni.cpp
include $(BUILD_SHARED_LIBRARY)
```

`application.mk` 

``` bash
APP_MODULES := hellojni  //生成的.so name

APP_ABI := all  //生成的.so 目标cpu平台
```
if you want to know more information of syntax about them, here is the dox
[http://android.mk/#intro](http://android.mk/#intro)

4, 编写你的natie-code 实现文件, (ig  .cpp or .c)


``` c++
#include "jniproject_ndkproject_MainActivity.h"

JNIEXPORT jstring JNICALL Java_jniproject_ndkproject_MainActivity_nativeMethod
       (JNIEnv *env, jclass type) {

    return env->NewStringUTF("this code from jni cpp");
}

```
as wo can see that in above c++ code 

first , you need to include you `.h`file

``` java
#include "jniproject_ndkproject_MainActivity.h"
```
接下来你需要按照c++ 代码的规范编写实现方法, 请注意方法实现的命名规范 (JNIEXPORT  返回值类型 JNICALL 包名_类名_方法名)

5, ndk-build 

under the `jni` dictionary, generate `.so` file 

``` java
luhuanju:jni huanjulu$ ndk-build

```
接下来你需要把生成的`app/src/main/libs` 下的平台的.so 文件复制到 `app/libs` 下

![Qualified types](http://opd7g7we7.bkt.clouddn.com/WX20170503-180432@2x.png)

6, `app/build.gradle` config seeting 

``` java
apply plugin: 'com.android.application'

android {
    compileSdkVersion 25
    buildToolsVersion "25.0.2"
    defaultConfig {
        applicationId "jniproject.ndkproject"
        minSdkVersion 15
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"


        ndk {//指定生成的lib，比如此时生成native.so
            moduleName   "hellojni"
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:25.2.0'
    compile 'com.android.support.constraint:constraint-layout:1.0.0-beta4'
    compile 'com.android.support:design:25.2.0'
    testCompile 'junit:junit:4.12'
}

```

the the last step is that you just need call you natice-code library 



``` java
package jniproject.ndkproject;

import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.widget.TextView;


/**
 * auth:huanjulu
 */

public class MainActivity extends AppCompatActivity {


    static {
        System.loadLibrary("hellojni");
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
        ((TextView) findViewById(R.id.text)).setText(nativeMethod());
    }
    /**
     * native code
     *
     * @return
     */
    public native String nativeMethod();

}

```




